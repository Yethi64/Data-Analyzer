# -*- coding: utf-8 -*-
"""streamlit_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h9wBCp-YXLk411cTtgTuR0oeudFYCFlV
"""

import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.signal import savgol_filter
from scipy.ndimage import uniform_filter1d
import io
import os
import zipfile

# Streamlit app title
st.title("Absorption Data Analyzer")

# File upload section
uploaded_files = st.file_uploader("Upload your dataset (.txt files)", type=['txt'], accept_multiple_files=True)

# Temporary directory to store images
temp_dir = "temp_images"
if not os.path.exists(temp_dir):
    os.makedirs(temp_dir)

# List to store filenames of the generated images
image_filenames = []

# Process each file
if uploaded_files:
    for uploaded_file in uploaded_files:
        # Load the dataset
        data = pd.read_csv(uploaded_file, sep='\t', header=None, names=['VarName1', 'VarName2', 'VarName3', 'VarName4', 'VarName5'], encoding='ISO-8859-1')

        # Time vector t (in minutes)
        data['t'] = np.arange(1, len(data) + 1) / 60

        # Apply Savitzky-Golay filter
        data['e'] = savgol_filter(data['VarName2'], window_length=351, polyorder=2)
        data['f'] = savgol_filter(data['VarName3'], window_length=351, polyorder=2)
        data['g'] = savgol_filter(data['VarName4'], window_length=351, polyorder=2)
        data['h'] = savgol_filter(data['VarName5'], window_length=351, polyorder=2)

        # Normalize the signals
        data['i'] = (data['e'] / data['e'].iloc[0]) * 100
        data['j'] = (data['f'] / data['i'].iloc[0])
        data['k'] = (data['g'] / data['i'].iloc[0])
        data['l'] = (data['h'] / data['i'].iloc[0])

        data['j'] = (data['j'] / data['j'].iloc[0]) * 100
        data['k'] = (data['k'] / data['k'].iloc[0]) * 100
        data['l'] = (data['l'] / data['l'].iloc[0]) * 100

        # Convert to % change
        data['aa'] = 100 - data['i']
        data['bb'] = 100 - data['j']
        data['cc'] = 100 - data['k']
        data['dd'] = 100 - data['l']

        # First derivative of % change
        a = np.diff(data['aa']) * 100
        b = np.diff(data['bb']) * 100
        c = np.diff(data['cc']) * 100
        d = np.diff(data['dd']) * 100

        # Apply moving average to first derivative
        a_smooth = uniform_filter1d(a, size=501)
        b_smooth = uniform_filter1d(b, size=501)
        c_smooth = uniform_filter1d(c, size=501)
        d_smooth = uniform_filter1d(d, size=501)

        # Time vector for the first derivative plot (in minutes)
        t_deriv = np.arange(1, len(a_smooth) + 1) / 60

        # Second derivative of the smoothed first derivatives
        e = np.diff(a_smooth) * 1000
        f = np.diff(b_smooth) * 1000
        g = np.diff(c_smooth) * 1000
        h = np.diff(d_smooth) * 1000

        # Apply Savitzky-Golay filter to the second derivatives
        e_smooth = savgol_filter(e, window_length=311, polyorder=2)
        f_smooth = savgol_filter(f, window_length=311, polyorder=2)
        g_smooth = savgol_filter(g, window_length=311, polyorder=2)
        h_smooth = savgol_filter(h, window_length=311, polyorder=2)

        # Time vector for the second derivative plot (in minutes)
        t_second_deriv = np.arange(1, len(e_smooth) + 1) / 60

        fig, axes = plt.subplots(1, 3, figsize=(18, 6))

        # Raw absorption data plot
        axes[0].plot(data['t'], data['aa'], label='well1')
        axes[0].plot(data['t'], data['bb'], label='well2')
        axes[0].plot(data['t'], data['cc'], label='well3')
        axes[0].plot(data['t'], data['dd'], label='well4')
        axes[0].set_xlabel('Time (min)')
        axes[0].set_ylabel('Absorption change in %')
        axes[0].legend()
        axes[0].set_title('Raw absorption data')

        # First derivative plot
        axes[1].plot(t_deriv, a_smooth, label='well1')
        axes[1].plot(t_deriv, b_smooth, label='well2')
        axes[1].plot(t_deriv, c_smooth, label='well3')
        axes[1].plot(t_deriv, d_smooth, label='well4')
        axes[1].set_xlabel('Time (min)')
        axes[1].legend()
        axes[1].set_title('First derivative')

        # Second derivative plot
        axes[2].plot(t_second_deriv, e_smooth, label='well1')
        axes[2].plot(t_second_deriv, f_smooth, label='well2')
        axes[2].plot(t_second_deriv, g_smooth, label='well3')
        axes[2].plot(t_second_deriv, h_smooth, label='well4')
        axes[2].axhline(0, color='gray', linestyle='--', label='Threshold')
        axes[2].set_xlabel('Time (min)')
        axes[2].legend()
        axes[2].set_title('Second derivative')

        # Save the figure as a PNG file
        image_filename = os.path.join(temp_dir, f"{uploaded_file.name}_graphs.png")
        plt.savefig(image_filename)
        plt.close(fig)

        # Add the image file to the list
        image_filenames.append(image_filename)

    # Create a zip file of all images
    zip_filename = "all_graphs.zip"
    zip_path = os.path.join(temp_dir, zip_filename)
    with zipfile.ZipFile(zip_path, 'w') as zipf:
        for file in image_filenames:
            zipf.write(file, os.path.basename(file))

    # Provide a single download button for the zip file
    with open(zip_path, "rb") as f:
        st.download_button(
            label="Download All Graphs as ZIP",
            data=f,
            file_name=zip_filename,
            mime="application/zip"
        )


        # # Save the figure to a BytesIO object
        # img_bytes = io.BytesIO()
        # plt.savefig(img_bytes, format='png')
        # plt.close(fig)
        # img_bytes.seek(0)

        # # Provide download link for the image
        # st.download_button(
        #     label=f"Download Graphs for {uploaded_file.name}",
        #     data=img_bytes,
        #     file_name=f"{uploaded_file.name}_graphs.png",
        #     mime="image/png"
        # )

